<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Dragon Ipsum - J is good</title>
	<link href="STYLE.css" rel="stylesheet">
	<link href="prism.css" rel="stylesheet">
	<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
	});
	</script>
	<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
	<header><span id="title"><a href="/blog">Dragon Ipsum</a></span></header>
	<div id="container">
		<p>Modified May 8, 2016.</p>
		<h1 id="j-is-good">J is good</h1>
<p>No, really, I&#8217;m serious. While it may not be practical, it sure is a fun thing to do with your brain. Y&#8217;know, a good mental exercise. You just have to memorize a few rules. I might right an intro to J later, but here&#8217;s some fun!</p>
<p>Let&#8217;s write the combinations formula into J. Remember this is:</p>
<p><span class="math display">\[_nC_r=:\frac{n!}{n!(n-r)!}\]</span></p>
<p>Here is how I go about doing this. First, I write this into a J snippet (i.e.&#160;one that has predefined variables, not tacit). (Note that J has prefix factorial, like <code>!n</code>.)</p>
<pre class="language-j"><code>(! n) % ((! n - r) * ! n)</code></pre>
<p>Now, I symbolically represent each verb with a symbol.</p>
<pre class="language-j"><code>u =: !
f =: %
g =: -
h =: *

(u n) f ((u (n g r)) h (u n))</code></pre>
<p>Now, this is a lot to digest. So I extract the more complicated bit and work on it separately.</p>
<pre class="language-j"><code>((u (n g r)) h (u n))</code></pre>
<p>Now, this looks vaguely like a fork:</p>
<pre class="language-j"><code>a (f g h) b
NB. is the same as
(a f b) g (a h b)</code></pre>
<p>Let&#8217;s look at the left part:</p>
<pre class="language-j"><code>(u (n g r))
NB. is equivalent to
n (u@g) r</code></pre>
<p>And now at the right part:</p>
<pre class="language-j"><code>(u n)
NB. is equivalent to
(n u@] r)</code></pre>
<p>So now we can write</p>
<pre class="language-j"><code>((u (n g r)) h (u n))
NB. is equivalent to
((n (u@g) r) h (u n))
NB. is equivalent to
((n (u@g) r) h (n u@] r))
NB. is equivalent to
n (u@g h u@]) r             NB. a fork</code></pre>
<p>Let&#8217;s insert that back into our larger formula.</p>
<pre class="language-j"><code>(u n) f ((u (n g r)) h (u n))
NB. is equivalent to
(u n) f (n (u@g h u@]) r)
NB. let&#39;s rewrite this as a fork
(n u@[ r) f (n (u@g h u@]))
NB. is equivalent to
n (u@[ f u@g h u@]) r</code></pre>
<p>Putting it all together, we get:</p>
<pre class="language-j"><code>!@[ % !@- * !@]
NB. minified:
!@[%!@-*!@]</code></pre>
<p>For me, that was an engaging experience. However, I may have explained some things wrong, so do correct me if I have.</p>
<p>Peace out, and stay good. Like J!</p>

	</div>
	<script src="prism.js" type="text/javascript"></script>
</body>
</html>