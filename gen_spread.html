<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Dragon Ipsum - Generators and the spread operator</title>
	<link href="STYLE.css" rel="stylesheet">
	<link href="prism.css" rel="stylesheet">
	<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
	});
	</script>
	<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	<script type="text/javascript" src="main.js"></script>
</head>
<body>
	<header><span id="title"><a href="/blog">Dragon Ipsum</a></span></header>
	<div id="container">
		<p>Modified June 17, 2016.</p>
		<h1 id="generators-and-the-spread-operator">Generators and the spread operator</h1>
<p>Generators and the spread operator in JavaScript are probably two of my favorite additions, just behind <code>let</code>, <code>const</code>, and arrow functions. It allows for richer functions to be constructed. Here&#8217;s an overview/tutorial of what it is, and how it can be used.</p>
<h2 id="the-beauty-of-generators">The beauty of generators</h2>
<p>Generators, if you are not already familiar, are a special type of function that are able to sequentially yield the outputs of a function. The way JavaScript generators work is that there is a main generator object, from which you can create <code>GeneratorFunction</code> instances. You can obtain a single step of this instance using the <code>next</code> method, which returns an object containing two key-value pairs, <code>value</code> and <code>done</code>. The <code>value</code> key is what is yielded by the generator, and <code>done</code> is a boolean saying whether or not the generator has anything left to yield. Generators are made using the <code>function*</code> and <code>yield</code> keywords. I&#8217;ll show you a simple generator which generates <code>1</code>, then <code>2</code>, then <code>3</code>, then stops.</p>
<pre class="language-js"><code>function* threeNumbers(){
    yield 1;
    yield 2;
    yield 3;
}</code></pre>
<p>To use this generator, assign the result of calling <code>threeNumbers</code> to a variable, then use it&#8217;s method <code>next</code>, like so:</p>
<pre class="language-js"><code>let a = threeNumbers();    // note that we&#39;re not using `new` here
a.next();                  // {value: 1, done: false}
a.next();                  // {value: 2, done: false}
a.next();                  // {value: 3, done: false}
a.next();                  // {value: undefined, done: true}</code></pre>
<p>This is a trivial generator, and can hardly be said to do anything useful. It is possible to create an infinite generator&#8211;any valid JS code can be used inside a generator. Each time the generator encounters <code>yield</code> it will pause what it is doing and return a value. Once <code>next</code> is called again, it will resume.</p>
<p>Generators can also take arguments. The arguments taken by generators become part of each <code>GeneratorFunction</code>s scope. To show this, let&#8217;s look at a generator that generates multiples of a given number.</p>
<pre class="language-js"><code>function* multiplesOf(num){
    let counter = 0;
    while(true){
        yield counter;
        counter += num;
    }
}

let of3 = multiplesOf(3);
of3.next().value;           // 0
of3.next().value;           // 3
of3.next().value;           // 6
of3.next().value;           // 9
// ... etc.</code></pre>
<h2 id="practical-usesymbol.iterator">Practical use&#8211;<code>Symbol.iterator</code></h2>
<p>While generators may be interesting, you are probably wondering how they are practical. Enter <code>Symbol.iterator</code>. An objects <code>Symbol.iterator</code> dictates how it behaves in <code>for..of</code> loops. Here&#8217;s a simple <code>Collection</code> class. (Note that <code>*name(){...}</code> in a class statement is a generator!)</p>
<pre class="language-js"><code>class Collection {
    constructor(){
        this.vals = [];
    }

    get size(){
        return this.vals.length;
    }

    retrieve(ind){
        return this.vals[ind];
    }

    add(val){
        this.vals.push(val);
    }

    *[Symbol.iterator](){
        for(let i = 0; i &lt; this.size; i++){
            yield this.retrieve(i);
        }
    }
}

let a = new Collection();
a.add(5);
a.add(3);
a.add(&quot;Hi!&quot;);
for(let p of a){
    console.log(p);
}
// logs:
// 5
// 3
// Hi!</code></pre>
<h2 id="the-spread-operator">The spread operator</h2>
<p>An <em>iterable object</em> is an object for which it&#8217;s <code>Symbol.iterator</code> is well-defined, as above. Simple! Not only is the <code>Symbol.iterator</code> used for <code>for..of</code> loops, it&#8217;s also used with the spread operator. The spread operator applies the yield of the iterable to a function, array, etc. For example, a string is iterable. Observe:</p>
<pre class="language-js"><code>for(let i of &quot;Hi!&quot;){
    console.log(i);
}
// logs:
// H
// i
// !</code></pre>
<p>Thus, we can apply its members to an array, or to a function:</p>
<pre class="language-js"><code>console.log([...&quot;Hi!&quot;]);    // [&quot;H&quot;, &quot;i&quot;, &quot;!&quot;]

let f = (x, y, z) =&gt; y + z + x;
console.log(f(...&quot;Hi!&quot;));   // &quot;i!H&quot;</code></pre>
<p>What I love about the spread operator is that you can use it as a function argument operator! When used in this way, it&#8217;s called the &#8220;rest operator&#8221;.</p>
<pre class="language-js"><code>// returns it&#39;s arguments as an array
// That is, `a` contains all the arguments of the function
let f = (...a) =&gt; a;

// `b` always contains the first argument, and `a` contains the rest
// `a` is an empty array when only one argument is given.
let g = (b, ...a) =&gt; [b, a];

// however, functions like (...a, k) are not valid -- the rest operator
// can only be used as the last argument to a function.</code></pre>
<h3 id="array-interaction-with-the-spread-operator">Array interaction with the spread operator</h3>
<p>Say you have an array <code>A</code> and a function <code>f</code>. Here is a chart dictating some helpful results.</p>
<pre class="language-js"><code>f = (a) =&gt; a;      f(A)     equals     A
f = (...a) =&gt; a;   f(A)     equals     [A]
f = (a) =&gt; a;      f(...A)  equals     A[0]
f = (...a) =&gt; a;   f(...A)  equals     A</code></pre>
<h3 id="my-personal-thoughts-on-the-rest-operator">My personal thoughts on the rest operator</h3>
<p>While I like the rest operator, I feel as if it could&#8217;ve been defined better. For example, there is little ambiguity when I write <code>(...a, b)</code>&#8211;I refer to an array <code>a</code> containing all but the last argument, which then is <code>b</code>. The question then is what the behaviour would be when only a single argument is passed. I would say that <code>a</code> should contain a single member, and let <code>b</code> be undefined, though I&#8217;m sure there would be contention on this subject.</p>
<h2 id="suggested-reading">Suggested reading</h2>
<ul>
<li><a href="http://blog.keithcirkel.co.uk/metaprogramming-in-es6-symbols/">Metaprogramming in ES6: Symbols and why they&#8217;re awesome</a> by Keith Cirkel.</li>
<li><a href="http://blog.vihan.org/index.php/2016/05/17/es6s-unique-symbols/">ES6&#8217;s Unique Symbols</a> by Vihan.</li>
</ul>

	</div>
	<script src="prism.js" type="text/javascript"></script>
</body>
</html>